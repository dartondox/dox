import 'dart:convert';
import 'dart:io';

import 'package:dox_annotation/dox_annotation.dart';
import 'package:dox_websocket/src/utils/constant.dart';
import 'package:dox_websocket/src/websocket_emitter.dart';
import 'package:dox_websocket/src/websocket_storage.dart';
import 'package:uuid/uuid.dart';

Uuid uuid = Uuid();

class WebsocketEventHandler implements WebsocketEvent {
  /// storage to store active socket connection
  final WebsocketStorage _storage = WebsocketStorage();

  /// registered websocket events listener
  final Map<String, Function> _events = <String, Function>{};

  /// register websocket event
  /// ```
  /// event.on('info', (SocketEmitter emitter, message) {
  ///   /// your logic here
  /// });
  /// ```
  @override
  void on(String event, Function controller) {
    _events[event] = controller;
  }

  WebsocketEventHandler();

  /// handle http request and convert into websocket
  @override
  Future<WebSocket?> handle(IDoxRequest req) async {
    WebSocket ws = await WebSocketTransformer.upgrade(req.httpRequest);

    /// create socket id for each client connection
    /// socketId is just `uuid` generated by us
    String socketId = _createSocketId();

    /// set default room id as route identifier
    String defaultRoomId = 'room:${req.getRouteIdentifier()}';

    /// prepare emitter to pass to controller
    WebsocketEmitter emitter = WebsocketEmitter(socketId, defaultRoomId);

    /// add to active ws connection storage to reuse later
    _storage.addWebSocketInfo(socketId, ws);

    /// add socket id to the room default room is the route eg. /ws
    _storage.addWebSocketIdToRoom(socketId, defaultRoomId);

    /// send connected event to client
    emitter.emitToSender('connected', <String, String>{'id': socketId});

    /// listen for new message sent from client
    ws.listen(
      (dynamic data) async {
        /// decode message to map
        Map<String, dynamic> payload = jsonDecode(data);

        String eventName = payload[WEB_SOCKET_EVENT_KEY];
        dynamic message = payload[WEB_SOCKET_MESSAGE_KEY];

        /// if event name is WEB_SOCKET_JOIN_ROOM_EVENT_NAME,
        /// join to the room and message is room name
        if (eventName == WEB_SOCKET_JOIN_ROOM_EVENT_NAME) {
          String room = defaultRoomId + message;
          _storage.addWebSocketIdToRoom(socketId, room);
          return;
        }

        /// get controller fom event controller
        /// eg. socket.on(eventName, controller);
        Function? controller = _events[eventName];

        if (controller == null) {
          return;
        }
        Function.apply(controller, <dynamic>[emitter, message]);
      },
      onDone: () {
        /// once websocket is disconnected, remove socket from
        /// active connection storage
        _storage.removeWebSocketInfo(socketId);
      },

      /// coverage:ignore-start
      onError: (dynamic error) {
        /// if websocket has error, remove socket from
        /// active connection storage
        _storage.removeWebSocketInfo(socketId);
      },

      /// coverage:ignore-end
    );

    /// return websocket, so that response controller
    /// do not close the connection
    return ws;
  }

  /// creating socket id with unique timestamp
  String _createSocketId() {
    return 'ws:${uuid.v4()}';
  }
}
